"""
وكيل التخطيط (Planning Agent).

يوفر هذا الوكيل واجهات API مستقلة لتوليد الخطط الاستراتيجية (Strategic Plans) والتعليمية.
"""

import asyncio
import importlib
import importlib.util
from contextlib import asynccontextmanager
from uuid import UUID

from fastapi import APIRouter, Depends, FastAPI
from pydantic import AliasChoices, BaseModel, Field
from sqlalchemy.ext.asyncio import AsyncSession
from sqlmodel import select

from microservices.planning_agent.database import get_session, init_db
from microservices.planning_agent.errors import setup_exception_handlers
from microservices.planning_agent.graph import graph
from microservices.planning_agent.health import HealthResponse, build_health_payload
from microservices.planning_agent.logging import get_logger, setup_logging
from microservices.planning_agent.models import Plan, PlanStep
from microservices.planning_agent.security import verify_service_token
from microservices.planning_agent.settings import PlanningAgentSettings, get_settings

logger = get_logger("planning-agent")


def _dspy_dependencies_available() -> bool:
    """يتحقق من توفر اعتمادات DSPy الأساسية قبل محاولة التحميل."""

    required_specs = (
        "dspy",
        "litellm",
        "openai",
        "openai.types.beta.threads.message_content",
    )
    for spec in required_specs:
        try:
            if importlib.util.find_spec(spec) is None:
                return False
        except ModuleNotFoundError:
            return False
    return True


def _load_dspy() -> object | None:
    """يحاول تحميل مكتبة DSPy إذا كانت متاحة دون تعطيل الخدمة."""

    if not _dspy_dependencies_available():
        logger.warning("مكتبة DSPy أو تبعياتها غير متاحة، سيتم تخطي التهيئة الذكية")
        return None

    return importlib.import_module("dspy")


# --- Unified Agent Protocol ---


class AgentRequest(BaseModel):
    caller_id: str
    target_service: str
    action: str
    payload: dict
    security_token: str | None = None


class AgentResponse(BaseModel):
    status: str
    data: dict | None = None
    error: str | None = None
    metrics: dict = {}


# ------------------------------


class PlanRequest(BaseModel):
    """حمولة طلب إنشاء خطة استراتيجية."""

    goal: str = Field(
        ..., description="الهدف الرئيسي للخطة", validation_alias=AliasChoices("objective", "goal")
    )
    context: dict | list = Field(default_factory=dict, description="سياق إضافي داعم (JSON)")


class PlanResponse(BaseModel):
    """استجابة توليد الخطة النهائية."""

    plan_id: UUID
    goal: str
    strategy_name: str
    reasoning: str
    steps: list[PlanStep]


def _get_fallback_plan(goal: str, context: dict | list) -> dict:
    """توليد خطة احتياطية مخصصة عند فشل النموذج الذكي."""
    base_steps = [
        {
            "name": "Step 1: Analyze Goal",
            "description": f"Analyze the goal: {goal}",
            "tool_hint": "reason_deeply",
        },
        {
            "name": "Step 2: Research",
            "description": "Gather information.",
            "tool_hint": "search_content",
        },
        {"name": "Step 3: Execute", "description": "Execute the plan.", "tool_hint": None},
    ]
    return {
        "strategy_name": "Fallback Strategy",
        "reasoning": "DSPy unavailable or failed.",
        "steps": base_steps,
    }


async def _generate_plan(goal: str, context: dict | list, settings: PlanningAgentSettings) -> dict:
    """
    يولد خطة باستخدام الرسم البياني الذكي (LangGraph + DSPy).
    """

    if not settings.OPENROUTER_API_KEY:
        logger.warning("مفتاح API غير موجود، استخدام الخطة الاحتياطية")
        return _get_fallback_plan(goal, context)

    initial_state = {
        "goal": goal,
        "context": context,
        "iterations": 0,
        "plan": [],
        "strategy_name": "",
        "reasoning": "",
        "score": 0.0,
        "feedback": "",
    }

    try:
        logger.info("Executing Planning Graph", extra={"goal": goal})
        # Run synchronous graph in a thread to prevent blocking the event loop
        result = await asyncio.to_thread(graph.invoke, initial_state)

        if result and "plan" in result and result["plan"]:
            return {
                "strategy_name": result.get("strategy_name", "Generated Strategy"),
                "reasoning": result.get("reasoning", "Generated by DSPy"),
                "steps": result["plan"],
            }

        logger.warning("Graph returned no plan")
        return _get_fallback_plan(goal, context)

    except Exception as e:
        logger.error("Graph Execution Failed", extra={"error": str(e)})
        return _get_fallback_plan(goal, context)


def _build_router() -> APIRouter:
    """ينشئ موجهات الوكيل."""

    router = APIRouter()

    @router.get("/health", response_model=HealthResponse, tags=["System"])
    def health_check(settings: PlanningAgentSettings = Depends(get_settings)) -> HealthResponse:
        """يفحص جاهزية الوكيل بشكل مستقل."""

        return build_health_payload(settings)

    @router.post(
        "/plans",
        response_model=PlanResponse,
        tags=["Planning"],
        summary="إنشاء خطة جديدة",
    )
    async def create_plan(
        payload: PlanRequest,
        session: AsyncSession = Depends(get_session),
        settings: PlanningAgentSettings = Depends(get_settings),
    ) -> PlanResponse:
        """ينشئ خطة استراتيجية جديدة بناءً على الهدف والسياق ويحفظها."""

        logger.info("Start planning", extra={"goal": payload.goal})

        result = await _generate_plan(payload.goal, payload.context, settings)

        steps_dicts = result["steps"]
        # Ensure steps are dicts matching PlanStep structure if they came as strings
        # (Though graph.py tries to ensure list[dict], fallback might be list[str])
        final_steps = []
        for s in steps_dicts:
            if isinstance(s, dict):
                final_steps.append(s)
            elif isinstance(s, str):
                final_steps.append({"name": "Step", "description": s, "tool_hint": None})

        plan = Plan(
            goal=payload.goal,
            strategy_name=result["strategy_name"],
            reasoning=result["reasoning"],
            steps=final_steps,
        )
        session.add(plan)
        await session.commit()
        await session.refresh(plan)

        # Convert dicts to PlanStep objects for response
        response_steps = [PlanStep(**s) for s in final_steps]

        return PlanResponse(
            plan_id=plan.id,
            goal=plan.goal,
            strategy_name=plan.strategy_name,
            reasoning=plan.reasoning,
            steps=response_steps,
        )

    @router.get(
        "/plans",
        response_model=list[PlanResponse],
        tags=["Planning"],
        summary="عرض الخطط المحفوظة",
    )
    async def list_plans(session: AsyncSession = Depends(get_session)) -> list[PlanResponse]:
        """يعرض جميع الخطط المحفوظة."""

        statement = select(Plan)
        result = await session.execute(statement)
        plans = result.scalars().all()

        return [
            PlanResponse(
                plan_id=p.id,
                goal=p.goal,
                strategy_name=p.strategy_name,
                reasoning=p.reasoning,
                steps=[PlanStep(**s) for s in p.steps],
            )
            for p in plans
        ]

    @router.post("/execute", response_model=AgentResponse, tags=["Agent"], include_in_schema=False)
    async def execute(
        request: AgentRequest,
        session: AsyncSession = Depends(get_session),
        settings: PlanningAgentSettings = Depends(get_settings),
    ) -> AgentResponse:
        """Unified Agent Execution Endpoint."""
        try:
            if request.action in ["generate_plan", "plan"]:
                goal = request.payload.get("goal") or request.payload.get("objective", "")
                context = request.payload.get("context", {})

                # Use internal logic
                result = await _generate_plan(goal, context, settings)

                # Optional: Persist
                plan = Plan(
                    goal=goal,
                    strategy_name=result["strategy_name"],
                    reasoning=result["reasoning"],
                    steps=result["steps"],
                )
                session.add(plan)
                await session.commit()

                return AgentResponse(status="success", data=result)

            return AgentResponse(status="error", error=f"Action {request.action} not supported")
        except Exception as e:
            return AgentResponse(status="error", error=str(e))

    return router


@asynccontextmanager
async def lifespan(app: FastAPI):
    """يدير دورة حياة وكيل التخطيط."""

    settings = get_settings()
    setup_logging(settings.SERVICE_NAME)

    # Configure DSPy
    if settings.OPENROUTER_API_KEY:
        dspy_module = _load_dspy()
        if dspy_module:
            try:
                lm = dspy_module.OpenAI(
                    model=settings.AI_MODEL,
                    api_key=settings.OPENROUTER_API_KEY.get_secret_value(),
                    api_base=settings.AI_BASE_URL,
                    max_tokens=2000,
                )
                dspy_module.settings.configure(lm=lm)
                logger.info("DSPy Configured successfully")
            except Exception as e:
                logger.error(f"Failed to configure DSPy: {e}")
        else:
            logger.warning("DSPy غير متاح، سيتم الاعتماد على الخطة الاحتياطية")
    else:
        logger.warning("No API Key configured for DSPy")

    logger.info("Planning Agent Started")
    await init_db()
    yield
    logger.info("Planning Agent Stopped")


def create_app(settings: PlanningAgentSettings | None = None) -> FastAPI:
    """ينشئ تطبيق FastAPI للوكيل مع حقن الإعدادات."""

    effective_settings = settings or get_settings()

    app = FastAPI(
        title="Planning Agent",
        version=effective_settings.SERVICE_VERSION,
        description="وكيل مستقل لتوليد الخطط الاستراتيجية (Smart Micro-service)",
        lifespan=lifespan,
    )
    setup_exception_handlers(app)

    # تطبيق Zero Trust: التحقق من الهوية عند البوابة
    app.include_router(_build_router(), dependencies=[Depends(verify_service_token)])

    return app


app = create_app()
